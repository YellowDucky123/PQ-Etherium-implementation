Metadata-Version: 2.1
Name: xmss-post-quantum
Version: 1.0.0
Summary: XMSS-based Post-Quantum Signature Scheme Implementation
Home-page: https://github.com/example/xmss-post-quantum
Author: XMSS Development Team
Author-email: example@example.com
License: UNKNOWN
Platform: UNKNOWN
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: Science/Research
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Topic :: Security :: Cryptography
Requires-Python: >=3.8
Description-Content-Type: text/markdown

# XMSS-based Post-Quantum Signature Scheme

This project implements the XMSS (eXtended Merkle Signature Scheme) variants for post-quantum blockchain security as described in the paper "Hash-Based Post-Quantum Signatures: A Study of XMSS Variants".

## Project Overview

This project provides a Python implementation of hash-based signature schemes suitable for post-quantum proof-of-stake blockchains. The implementation focuses on XMSS variants that can serve as post-quantum alternatives to BLS signatures, with efficient signature aggregation capabilities using pqSNARKs.

### Key Features

1. **XMSS Signature Scheme Implementation**: Implements the core XMSS signature scheme with Merkle trees and one-time signatures.
2. **Generalized XMSS Framework**: Provides a flexible framework (SIG[IncEnc,Th,K]) based on incomparable encodings.
3. **Winternitz One-Time Signatures**: Implements both classical and target-sum Winternitz one-time signature schemes.
4. **Post-Quantum Security**: Designed with standard model security proofs, avoiding random oracle model.
5. **Signature Aggregation Ready**: Optimized for efficient signature aggregation using pqSNARKs.

## Project Structure

```
├── README.md                           # Project documentation
├── requirements.txt                    # Python dependencies
├── xmss/
│   ├── __init__.py                     # Package initialization
│   ├── core/                          
│   │   ├── __init__.py                 # Core package initialization
│   │   ├── xmss.py                     # Main XMSS implementation
│   │   ├── keygen.py                   # Key generation algorithms
│   │   ├── signing.py                  # Signing algorithms
│   │   └── verification.py             # Verification algorithms
│   ├── otss/                          
│   │   ├── __init__.py                 # One-time signature scheme initialization
│   │   ├── winternitz.py               # Classical Winternitz OTS implementation
│   │   ├── target_sum_winternitz.py    # Target-sum Winternitz OTS implementation
│   │   └── base.py                     # Base OTS class
│   ├── merkle/
│   │   ├── __init__.py                 # Merkle tree package initialization
│   │   ├── tree.py                     # Merkle tree implementation
│   │   └── path.py                     # Merkle path operations
│   ├── encoding/
│   │   ├── __init__.py                 # Encoding package initialization
│   │   ├── incomparable.py             # Incomparable encoding schemes
│   │   └── base.py                     # Base encoding class
│   ├── hash_functions/
│   │   ├── __init__.py                 # Hash functions package initialization
│   │   ├── tweakable.py                # Tweakable hash functions
│   │   ├── sha3.py                     # SHA-3 based implementations
│   │   └── poseidon.py                 # Poseidon based implementations
│   ├── security/
│   │   ├── __init__.py                 # Security package initialization
│   │   ├── proof.py                    # Security proof framework
│   │   └── analysis.py                 # Security analysis tools
│   └── utils/
│       ├── __init__.py                 # Utilities package initialization
│       ├── helpers.py                  # Helper functions
│       └── constants.py                # Constants and parameters
├── examples/
│   ├── __init__.py                     # Examples package initialization
│   ├── basic_usage.py                  # Basic usage examples
│   └── benchmark.py                    # Performance benchmarks
└── tests/
    ├── __init__.py                     # Tests package initialization
    ├── test_xmss.py                    # XMSS implementation tests
    ├── test_winternitz.py              # Winternitz OTS tests
    ├── test_merkle.py                  # Merkle tree tests
    └── test_encoding.py                # Encoding tests
```

## Core Components

### 1. XMSS Core Module

The core XMSS implementation provides the main signature scheme functionality:

- Key generation
- Signing
- Verification
- State management

### 2. One-Time Signature Schemes (OTSS)

Implementation of Winternitz one-time signatures:

- Classical Winternitz with checksum
- Target-sum Winternitz without checksum
- Base OTS interface

### 3. Merkle Tree Module

Merkle tree implementation for key commitment:

- Tree construction
- Path generation and verification
- Root calculation

### 4. Encoding Module

Incomparable encoding abstraction:

- Incomparable encoding schemes
- Message encoding/decoding
- Error handling

### 5. Hash Functions Module

Tweakable hash functions for different purposes:

- Message hashing
- Chain hashing
- Leaf hashing
- Tree hashing

### 6. Security Module

Security analysis and proof framework:

- Standard model security proofs
- Strong unforgeability analysis
- Security parameter selection

## Design Principles

### 1. Synchronized Signature Suitability

The implementation is optimized for proof-of-stake environments where validators sign only one message per epoch, making synchronized (stateful) signature schemes highly suitable.

### 2. Signature Aggregation Paradigm

The classical approach of converting one-time signatures to many-time signatures:
- Signers commit to a long list of one-time public keys using Merkle trees
- The Merkle root serves as the (many-time) public key
- To sign the i-th message, the signer uses the i-th one-time private key and includes the one-time public key along with the Merkle path

### 3. Verification Efficiency Optimization

Focus on reducing the number of hash operations in the verification algorithm, which directly impacts the computational cost of generating succinct arguments for signature aggregation.

### 4. Incomparable Encoding Abstraction

Introduction of a new abstraction for unified analysis of XMSS-like schemes, ensuring that encodings of different messages are "incomparable" in some sense, which is crucial for security proofs.

## Usage

### Basic Usage

```python
from xmss.core.xmss import XMSS
from xmss.otss.winternitz import WinternitzOTS

# Create a Winternitz OTS scheme
ots_scheme = WinternitzOTS(w=4)

# Create XMSS scheme
xmss = XMSS(ots_scheme=ots_scheme, height=3)  # 8 possible signatures

# Generate keypair
private_key, public_key = xmss.generate_keypair()

# Sign a message
message = b"Hello, XMSS!"
signature = xmss.sign(message)

# Verify the signature
is_valid = xmss.verify(message, signature)
```

### Running Examples

To run the basic usage example:

```bash
python examples/basic_usage.py
```

## References

1. "Hash-Based Post-Quantum Signatures: A Study of XMSS Variants"
2. XMSS: Extended Hash-Based Signatures RFC 8391
3. RFC 6379: Suite B Cryptographic Algorithms
4. NIST Post-Quantum Cryptography Standardization

